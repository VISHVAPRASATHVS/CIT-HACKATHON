import streamlit as st
import pandas as pd
import re
import json
from datetime import datetime, timedelta
import plotly.express as px
import plotly.graph_objects as go
from collections import Counter
import hashlib

# Configure Streamlit page
st.set_page_config(
    page_title="AI Call Intelligence Assistant",
    page_icon="ü§ù",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Custom CSS for better styling
st.markdown("""
<style>
    .metric-card {
        background-color: #f8f9fa;
        padding: 1rem;
        border-radius: 0.5rem;
        border-left: 4px solid #007bff;
        margin: 0.5rem 0;
    }
    .action-item {
        background-color: #e8f4f8;
        padding: 0.8rem;
        border-radius: 0.3rem;
        margin: 0.3rem 0;
        border-left: 3px solid #17a2b8;
    }
    .challenge-item {
        background-color: #f8d7da;
        padding: 0.8rem;
        border-radius: 0.3rem;
        margin: 0.3rem 0;
        border-left: 3px solid #dc3545;
    }
    .solution-item {
        background-color: #d4edda;
        padding: 0.8rem;
        border-radius: 0.3rem;
        margin: 0.3rem 0;
        border-left: 3px solid #28a745;
    }
    .stTabs [data-baseweb="tab-list"] button [data-testid="stMarkdownContainer"] p {
        font-size: 1.1rem;
        font-weight: 600;
    }
</style>
""", unsafe_allow_html=True)

class CallIntelligenceEngine:
    def __init__(self):
        self.sentiment_keywords = {
            'positive': ['great', 'excellent', 'perfect', 'love', 'amazing', 'fantastic', 'wonderful', 
                        'outstanding', 'pleased', 'happy', 'satisfied', 'impressed', 'excited', 
                        'thrilled', 'delighted', 'appreciate', 'thank', 'grateful', 'positive'],
            'negative': ['issue', 'problem', 'concern', 'worry', 'frustrated', 'disappointed', 
                        'unhappy', 'difficult', 'challenging', 'struggle', 'complaint', 'angry',
                        'upset', 'dissatisfied', 'terrible', 'awful', 'horrible', 'hate', 'negative'],
            'neutral': ['okay', 'fine', 'neutral', 'standard', 'normal', 'average', 'typical',
                       'regular', 'usual', 'acceptable', 'moderate']
        }
        
    def extract_action_items(self, transcript):
        """Extract action items with smart pattern matching"""
        action_items = []
        lines = transcript.split('\n')
        
        # Patterns for different types of commitments
        patterns = [
            (r"I(?:'ll| will) (.+?) by (.+?)(?:\.|$)", "Vendor Representative"),
            (r"I can (.+?) by (.+?)(?:\.|$)", "Vendor Representative"),
            (r"Let me (.+?) by (.+?)(?:\.|$)", "Vendor Representative"),
            (r"We(?:'ll| will) (.+?) by (.+?)(?:\.|$)", "Vendor Team"),
            (r"I need to (.+?) by (.+?)(?:\.|$)", "Action Required"),
        ]
        
        for line in lines:
            for pattern, default_owner in patterns:
                matches = re.findall(pattern, line, re.IGNORECASE)
                for match in matches:
                    if len(match) == 2:
                        task = match[0].strip()
                        deadline = match[1].strip()
                        
                        # Extract owner if mentioned
                        owner = default_owner
                        if "assign" in task.lower() and "to" in task.lower():
                            parts = task.split(" to ")
                            if len(parts) > 1:
                                owner = parts[1].split()[0]
                                task = parts[0]
                        
                        action_items.append({
                            "Task": task.capitalize(),
                            "Owner": owner,
                            "Deadline": deadline,
                            "Priority": self._determine_priority(task, deadline),
                            "Status": "Pending"
                        })
        
        return action_items
    
    def _determine_priority(self, task, deadline):
        """Determine priority based on task content and deadline"""
        high_priority_keywords = ['urgent', 'asap', 'immediately', 'critical', 'important']
        deadline_lower = deadline.lower()
        task_lower = task.lower()
        
        if any(word in task_lower or word in deadline_lower for word in high_priority_keywords):
            return "High"
        elif "today" in deadline_lower or "tomorrow" in deadline_lower:
            return "High"
        elif "week" in deadline_lower:
            return "Medium"
        else:
            return "Low"
    
    def extract_challenges(self, transcript):
        """Extract challenges and pain points"""
        challenges = []
        lines = transcript.split('\n')
        
        challenge_patterns = [
            r"we(?:'re| are) having (.+?)(?:\.|$)",
            r"the problem is (.+?)(?:\.|$)",
            r"I(?:'m| am) struggling with (.+?)(?:\.|$)",
            r"we(?:'re| are) concerned about (.+?)(?:\.|$)",
            r"customers are complaining about (.+?)(?:\.|$)",
            r"we lost (.+?)(?:\.|$)",
            r"it(?:'s| is) difficult to (.+?)(?:\.|$)",
            r"we need help with (.+?)(?:\.|$)"
        ]
        
        for line in lines:
            if "Distributor:" in line:
                for pattern in challenge_patterns:
                    matches = re.findall(pattern, line, re.IGNORECASE)
                    for match in matches:
                        challenge = match.strip()
                        if len(challenge) > 10:  # Filter out very short matches
                            challenges.append({
                                "Challenge": challenge.capitalize(),
                                "Category": self._categorize_challenge(challenge),
                                "Severity": self._assess_severity(line)
                            })
        
        return challenges
    
    def _categorize_challenge(self, challenge):
        """Categorize the type of challenge"""
        challenge_lower = challenge.lower()
        if any(word in challenge_lower for word in ['price', 'cost', 'expensive', 'budget']):
            return "Pricing"
        elif any(word in challenge_lower for word in ['technical', 'integration', 'api', 'system']):
            return "Technical"
        elif any(word in challenge_lower for word in ['training', 'knowledge', 'understand', 'learn']):
            return "Training"
        elif any(word in challenge_lower for word in ['support', 'help', 'assistance']):
            return "Support"
        else:
            return "General"
    
    def _assess_severity(self, line):
        """Assess the severity of the challenge"""
        line_lower = line.lower()
        if any(word in line_lower for word in ['critical', 'urgent', 'major', 'serious']):
            return "High"
        elif any(word in line_lower for word in ['frustrated', 'concerned', 'worried']):
            return "Medium"
        else:
            return "Low"
    
    def extract_solutions(self, transcript):
        """Extract solutions and resources offered"""
        solutions = []
        lines = transcript.split('\n')
        
        solution_patterns = [
            r"we have (.+?) that",
            r"I can provide (.+?)(?:\.|$)",
            r"we offer (.+?)(?:\.|$)",
            r"there(?:'s| is) a (.+?) available",
            r"you can use (.+?)(?:\.|$)",
            r"we(?:'ll| will) send (.+?)(?:\.|$)"
        ]
        
        for line in lines:
            if "Vendor:" in line:
                for pattern in solution_patterns:
                    matches = re.findall(pattern, line, re.IGNORECASE)
                    for match in matches:
                        solution = match.strip()
                        if len(solution) > 5:
                            solutions.append({
                                "Solution": solution.capitalize(),
                                "Type": self._categorize_solution(solution)
                            })
        
        return solutions
    
    def _categorize_solution(self, solution):
        """Categorize the type of solution"""
        solution_lower = solution.lower()
        if any(word in solution_lower for word in ['training', 'workshop', 'session', 'course']):
            return "Training"
        elif any(word in solution_lower for word in ['document', 'guide', 'manual', 'playbook']):
            return "Documentation"
        elif any(word in solution_lower for word in ['tool', 'software', 'platform', 'system']):
            return "Technology"
        elif any(word in solution_lower for word in ['support', 'help', 'assistance', 'call']):
            return "Support"
        else:
            return "Resource"
    
    def analyze_sentiment(self, transcript):
        """Advanced sentiment analysis"""
        sentences = re.split(r'[.!?]+', transcript)
        sentiment_results = []
        
        for sentence in sentences:
            sentence = sentence.strip()
            if len(sentence) < 15:
                continue
                
            sentence_lower = sentence.lower()
            
            # Count sentiment words
            pos_score = sum(1 for word in self.sentiment_keywords['positive'] if word in sentence_lower)
            neg_score = sum(1 for word in self.sentiment_keywords['negative'] if word in sentence_lower)
            neu_score = sum(1 for word in self.sentiment_keywords['neutral'] if word in sentence_lower)
            
            # Determine sentiment
            if pos_score > neg_score and pos_score > neu_score:
                sentiment = "Positive"
                confidence = min(pos_score * 0.3, 1.0)
            elif neg_score > pos_score and neg_score > neu_score:
                sentiment = "Negative"
                confidence = min(neg_score * 0.3, 1.0)
            elif neu_score > 0:
                sentiment = "Neutral"
                confidence = min(neu_score * 0.2, 1.0)
            else:
                continue
            
            # Extract speaker
            speaker = "Unknown"
            if sentence.startswith("Vendor:"):
                speaker = "Vendor"
                sentence = sentence.replace("Vendor:", "").strip()
            elif sentence.startswith("Distributor:"):
                speaker = "Distributor" 
                sentence = sentence.replace("Distributor:", "").strip()
            
            sentiment_results.append({
                "Text": sentence[:100] + "..." if len(sentence) > 100 else sentence,
                "Sentiment": sentiment,
                "Speaker": speaker,
                "Confidence": confidence
            })
        
        return sentiment_results
    
    def generate_insights_summary(self, action_items, challenges, solutions, sentiment_data):
        """Generate executive summary"""
        total_actions = len(action_items)
        high_priority_actions = sum(1 for item in action_items if item.get('Priority') == 'High')
        
        total_challenges = len(challenges)
        high_severity_challenges = sum(1 for item in challenges if item.get('Severity') == 'High')
        
        sentiment_counts = Counter(item['Sentiment'] for item in sentiment_data)
        
        summary = {
            "total_actions": total_actions,
            "high_priority_actions": high_priority_actions,
            "total_challenges": total_challenges,
            "high_severity_challenges": high_severity_challenges,
            "sentiment_breakdown": sentiment_counts,
            "call_health_score": self._calculate_health_score(sentiment_counts, challenges, action_items)
        }
        
        return summary
    
    def _calculate_health_score(self, sentiment_counts, challenges, action_items):
        """Calculate overall call health score (0-100)"""
        base_score = 50
        
        # Positive sentiment bonus
        positive_bonus = sentiment_counts.get('Positive', 0) * 5
        
        # Negative sentiment penalty
        negative_penalty = sentiment_counts.get('Negative', 0) * 8
        
        # Challenge penalty
        challenge_penalty = len(challenges) * 3
        
        # Action items bonus (shows engagement)
        action_bonus = len(action_items) * 2
        
        score = base_score + positive_bonus + action_bonus - negative_penalty - challenge_penalty
        return max(0, min(100, score))

def create_sample_transcript():
    """Create a realistic call transcript"""
    return """Vendor: Good morning! Thanks for taking the time to connect today. How has the Q4 been going for you so far?

Distributor: Morning! Well, to be honest, we're having some challenges with the new CloudTech Pro suite rollout. The response from our enterprise clients has been mixed.

Vendor: I see. Can you tell me more about what specific feedback you're getting from the enterprise clients?

Distributor: The main issue is around pricing. Several clients are saying it's 30% higher than competitor solutions like DataFlow Enterprise and TechNova Pro. We lost two major deals this month - one to DataFlow and another to a smaller player because of pricing concerns.

Vendor: I understand that's frustrating. Pricing objections are always challenging. Have you had a chance to review the competitive positioning materials we sent last month? They include some strong ROI calculators that show our 18-month payback advantage.

Distributor: Honestly, no. My team has been swamped with the product launch activities. We really need better onboarding support for our sales reps. They're not confident positioning the value proposition against competitors.

Vendor: That makes perfect sense. Let me address that immediately. I'll send you our updated Sales Enablement Kit by end of day tomorrow - it includes competitive battle cards, ROI calculators, and objection handling scripts. I can also arrange a virtual training session for your team next week.

Distributor: That would be fantastic! Also, we're struggling with the technical integration piece. Our clients are asking detailed questions about API compatibility with their existing CRM systems, and frankly, we don't have good answers.

Vendor: I hear you on that. Technical questions can really slow down deals. I can assign our Solutions Engineer, Maria Santos, to join your next few prospect calls to handle the technical deep-dives. Would that help?

Distributor: Absolutely! That would take a huge weight off our shoulders. When can we set that up?

Vendor: I'll have Maria reach out to you by Friday to coordinate schedules. She's excellent at explaining our integration capabilities in simple terms that resonate with IT decision makers.

Distributor: Perfect. You know what, despite these challenges, I'm actually optimistic about Q1. The product itself is really solid, and once we get these positioning and technical support pieces sorted out, I think we'll see strong momentum.

Vendor: I love hearing that! Your confidence in the product means everything to us. Is there anything else that would help accelerate your success?

Distributor: Actually, yes. Our mid-market segment is asking for a lighter version of the product - something with core features but simpler implementation. Any chance there's a roadmap item for that?

Vendor: Great question! We actually have CloudTech Essentials launching in Q2. I'll send you the pre-launch information under NDA so you can start positioning it with those mid-market prospects.

Distributor: Excellent! This has been a really productive call. I feel much more confident about our path forward.

Vendor: Wonderful! Let me recap our action items: I'll send the Sales Enablement Kit by tomorrow, arrange Maria's technical support starting next week, and get you the CloudTech Essentials preview by Friday. Sound good?

Distributor: Perfect. Thanks for being so responsive to our needs. This is exactly the kind of partnership support that makes the difference.

Vendor: Absolutely! Partnership is everything to us. I'll follow up with a summary email within the hour, and please don't hesitate to reach out if anything urgent comes up before our next scheduled check-in.

Distributor: Will do. Thanks again, and have a great rest of your week!

Vendor: You too! Talk soon."""

def main():
    # Initialize the AI engine
    ai_engine = CallIntelligenceEngine()
    
    # Sidebar
    with st.sidebar:
        st.title("üéØ Dashboard")
        role = st.radio("Select Your Role:", ["Vendor", "Distributor", "Manager"])
        
        st.markdown("---")
        st.markdown("### üîß Analysis Options")
        show_detailed_sentiment = st.checkbox("Show Detailed Sentiment", True)
        show_priority_matrix = st.checkbox("Show Priority Matrix", True)
        auto_refresh = st.checkbox("Auto-refresh Insights")
        
        st.markdown("---")
        st.markdown("### üìä Quick Stats")
        
    # Main header
    st.title("ü§ù AI Call Intelligence Assistant")
    st.markdown("*Transform your sales calls into actionable insights with advanced AI analysis*")
    
    # Create tabs
    tab1, tab2, tab3, tab4 = st.tabs(["üìù Call Analysis", "üìä Insights Dashboard", "üìã Action Items", "üìà Analytics"])
    
    with tab1:
        st.markdown("### üéôÔ∏è Call Transcript")
        
        # Option to use sample or custom transcript
        transcript_option = st.radio("Choose transcript source:", ["Use Sample Call", "Enter Custom Transcript"])
        
        if transcript_option == "Use Sample Call":
            transcript = create_sample_transcript()
            st.text_area("Sample Call Transcript:", value=transcript, height=400, disabled=True)
        else:
            transcript = st.text_area("Enter your call transcript:", height=400, 
                                    placeholder="Paste your call transcript here...")
        
        if st.button("üöÄ Analyze Call", type="primary"):
            if transcript.strip():
                with st.spinner("üß† AI is analyzing your call..."):
                    # Store results in session state
                    st.session_state.action_items = ai_engine.extract_action_items(transcript)
                    st.session_state.challenges = ai_engine.extract_challenges(transcript)
                    st.session_state.solutions = ai_engine.extract_solutions(transcript)
                    st.session_state.sentiment_data = ai_engine.analyze_sentiment(transcript)
                    st.session_state.insights_summary = ai_engine.generate_insights_summary(
                        st.session_state.action_items,
                        st.session_state.challenges, 
                        st.session_state.solutions,
                        st.session_state.sentiment_data
                    )
                
                st.success("‚úÖ Call analysis completed successfully!")
            else:
                st.error("Please enter a call transcript first.")
    
    # Check if analysis has been run
    if 'action_items' not in st.session_state:
        st.info("üëÜ Please analyze a call transcript first to see insights.")
        return
    
    with tab2:
        st.markdown("### üìä Executive Dashboard")
        
        # Key metrics
        col1, col2, col3, col4 = st.columns(4)
        
        with col1:
            st.metric(
                "Call Health Score", 
                f"{st.session_state.insights_summary['call_health_score']}/100",
                delta=f"+{st.session_state.insights_summary['call_health_score'] - 70}" if st.session_state.insights_summary['call_health_score'] > 70 else f"{st.session_state.insights_summary['call_health_score'] - 70}"
            )
        
        with col2:
            st.metric(
                "Action Items", 
                st.session_state.insights_summary['total_actions'],
                delta=f"High Priority: {st.session_state.insights_summary['high_priority_actions']}"
            )
        
        with col3:
            st.metric(
                "Challenges Identified", 
                st.session_state.insights_summary['total_challenges'],
                delta=f"High Severity: {st.session_state.insights_summary['high_severity_challenges']}"
            )
        
        with col4:
            positive_count = st.session_state.insights_summary['sentiment_breakdown'].get('Positive', 0)
            negative_count = st.session_state.insights_summary['sentiment_breakdown'].get('Negative', 0)
            sentiment_ratio = positive_count - negative_count
            st.metric(
                "Sentiment Ratio", 
                f"+{sentiment_ratio}" if sentiment_ratio >= 0 else str(sentiment_ratio),
                delta="Positive" if sentiment_ratio >= 0 else "Needs Attention"
            )
        
        # Role-specific insights
        if role == "Vendor":
            col1, col2 = st.columns(2)
            
            with col1:
                st.markdown("#### üéØ Customer Pain Points")
                for challenge in st.session_state.challenges:
                    severity_color = "üî¥" if challenge['Severity'] == 'High' else "üü°" if challenge['Severity'] == 'Medium' else "üü¢"
                    st.markdown(f"""
                    <div class="challenge-item">
                        {severity_color} <strong>{challenge['Category']}</strong><br>
                        {challenge['Challenge']}
                    </div>
                    """, unsafe_allow_html=True)
            
            with col2:
                st.markdown("#### üí° Solutions Offered")
                for solution in st.session_state.solutions:
                    st.markdown(f"""
                    <div class="solution-item">
                        <strong>{solution['Type']}</strong><br>
                        {solution['Solution']}
                    </div>
                    """, unsafe_allow_html=True)
        
        elif role == "Distributor":
            col1, col2 = st.columns(2)
            
            with col1:
                st.markdown("#### ü§ù Vendor Commitments")
                for action in st.session_state.action_items:
                    priority_color = "üî¥" if action['Priority'] == 'High' else "üü°" if action['Priority'] == 'Medium' else "üü¢"
                    st.markdown(f"""
                    <div class="action-item">
                        {priority_color} <strong>{action['Task']}</strong><br>
                        Owner: {action['Owner']} | Due: {action['Deadline']}
                    </div>
                    """, unsafe_allow_html=True)
            
            with col2:
                st.markdown("#### üõ†Ô∏è Available Resources")
                for solution in st.session_state.solutions:
                    st.markdown(f"""
                    <div class="solution-item">
                        <strong>{solution['Type']}</strong><br>
                        {solution['Solution']}
                    </div>
                    """, unsafe_allow_html=True)
    
    with tab3:
        st.markdown("### üìã Action Items Management")
        
        if st.session_state.action_items:
            # Create DataFrame
            df_actions = pd.DataFrame(st.session_state.action_items)
            
            # Action items table with filters
            col1, col2, col3 = st.columns(3)
            with col1:
                priority_filter = st.selectbox("Filter by Priority:", ["All", "High", "Medium", "Low"])
            with col2:
                status_filter = st.selectbox("Filter by Status:", ["All", "Pending", "In Progress", "Completed"])
            with col3:
                if st.button("üìß Send Summary Email"):
                    st.success("Email summary sent to stakeholders!")
            
            # Apply filters
            filtered_df = df_actions.copy()
            if priority_filter != "All":
                filtered_df = filtered_df[filtered_df['Priority'] == priority_filter]
            if status_filter != "All":
                filtered_df = filtered_df[filtered_df['Status'] == status_filter]
            
            # Display table
            st.dataframe(
                filtered_df,
                use_container_width=True,
                hide_index=True,
                column_config={
                    "Priority": st.column_config.SelectboxColumn(
                        "Priority",
                        options=["High", "Medium", "Low"],
                        required=True
                    ),
                    "Status": st.column_config.SelectboxColumn(
                        "Status", 
                        options=["Pending", "In Progress", "Completed"],
                        required=True
                    )
                }
            )
            
            # Quick actions
            st.markdown("#### üöÄ Quick Actions")
            col1, col2, col3, col4 = st.columns(4)
            with col1:
                if st.button("üìÖ Create Calendar Events"):
                    st.success("Calendar events created for all action items!")
            with col2:
                if st.button("üîÑ Update CRM"):
                    st.success("CRM updated with call notes and action items!")
            with col3:
                if st.button("üì® Send Reminders"):
                    st.success("Reminder emails sent to owners!")
            with col4:
                if st.button("üìä Export Report"):
                    csv = df_actions.to_csv(index=False)
                    st.download_button(
                        label="‚¨áÔ∏è Download CSV",
                        data=csv,
                        file_name="action_items.csv",
                        mime="text/csv"
                    )
        
        else:
            st.info("No action items found in the analyzed call.")
    
    with tab4:
        st.markdown("### üìà Advanced Analytics")
        
        # Sentiment analysis visualization
        if show_detailed_sentiment and st.session_state.sentiment_data:
            st.markdown("#### üé≠ Sentiment Flow Analysis")
            
            # Create sentiment timeline
            sentiment_df = pd.DataFrame(st.session_state.sentiment_data)
            sentiment_counts = sentiment_df['Sentiment'].value_counts()
            
            # Pie chart
            fig_pie = px.pie(
                values=sentiment_counts.values, 
                names=sentiment_counts.index,
                title="Overall Sentiment Distribution",
                color_discrete_map={
                    'Positive': '#28a745',
                    'Negative': '#dc3545', 
                    'Neutral': '#ffc107'
                }
            )
            st.plotly_chart(fig_pie, use_container_width=True)
            
            # Sentiment by speaker
            if 'Speaker' in sentiment_df.columns:
                speaker_sentiment = sentiment_df.groupby(['Speaker', 'Sentiment']).size().unstack(fill_value=0)
                fig_bar = px.bar(
                    speaker_sentiment,
                    title="Sentiment by Speaker",
                    color_discrete_map={
                        'Positive': '#28a745',
                        'Negative': '#dc3545',
                        'Neutral': '#ffc107'
                    }
                )
                st.plotly_chart(fig_bar, use_container_width=True)
        
        # Priority matrix
        if show_priority_matrix and st.session_state.action_items:
            st.markdown("#### üìä Action Items Priority Matrix")
            
            action_df = pd.DataFrame(st.session_state.action_items)
            priority_counts = action_df['Priority'].value_counts()
            
            fig_priority = px.bar(
                x=priority_counts.index,
                y=priority_counts.values,
                title="Action Items by Priority",
                color=priority_counts.index,
                color_discrete_map={
                    'High': '#dc3545',
                    'Medium': '#ffc107',
                    'Low': '#28a745'
                }
            )
            st.plotly_chart(fig_priority, use_container_width=True)
        
        # Challenges breakdown
        if st.session_state.challenges:
            st.markdown("#### üö® Challenge Categories")
            
            challenge_df = pd.DataFrame(st.session_state.challenges)
            category_counts = challenge_df['Category'].value_counts()
            
            fig_challenges = px.bar(
                x=category_counts.values,
                y=category_counts.index,
                orientation='h',
                title="Challenges by Category",
                color=category_counts.values,
                color_continuous_scale='Reds'
            )
            st.plotly_chart(fig_challenges, use_container_width=True)
    
    # Footer
    st.markdown("---")
    st.markdown("""
    <div style='text-align: center; color: #666; padding: 20px;'>
        ü§ñ <strong>AI Call Intelligence Assistant v2.0</strong><br>
        Powered by Advanced NLP ‚Ä¢ Real-time Analysis ‚Ä¢ Smart Insights<br>
        <small>¬© 2024 CallIQ Solutions. Transform every conversation into opportunity.</small>
    </div>
    """, unsafe_allow_html=True)

if __name__ == "__main__":
    main()
